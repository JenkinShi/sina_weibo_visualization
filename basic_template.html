<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Drawing Curves</title>
	<script type="text/javascript" src="./js/_VisualSedimentation.js"></script>
	
	<style type="text/css">
		
		.axis path,
		.axis line {
			fill: none;
			stroke: black;
			shape-rendering: crispEdges;
		}
		
		.axis, #second-clock text {
			font-family: sans-serif;
			font-size: 13px;
		}

	</style>
	<script type="text/javascript">
	var width = 800;
	var height = 320;
	var marginTop;
	var marginBottom = 25;
	var step = 4;
	var colorNum = 20;
	var colorTable = ['#C0C0C0','#F0C0F0','#E3CF57','#FF6103','#B0E0E6',
					'#D2691E','#00C957','#808069','#FFC0CB','#3D59AB',
					'#8A2BE2','#7CFC00','#FF8000','#03A89E','#FF4500',
					'#de9c53','#823635','#89bebe','#c51f1f','#113f3d'];
	var dataset_whole = [];
	var intervel = 0.5;

	var left_pos = [100, 251, 502];
	var right_pos = [250, 501, 782];
	var step_amount = [];

	var svg;

	//var namesInOrder = ['a','b','c'];
	var colorsInOrder = [5,2, 4, 3,1];
	var pathOrder = ['b','e','a','c','d'];
	var recentTopic = ['b','c','d'];
	var recnetColorsInOrder = [5, 3, 1];
	var recentHot = [1112,2231,1321];
	var recentTime = 267;
	var time_density = [1,5,10]
	var time_minute = [];

	var sceneSettings;
	var barChart;
	var barHeight = 300;
	var barWidth = 80;
	var maxData;
	var totalHeight = 0;
	var second = 12;
	var posTwoDaysBetween;
	var basic_base;


	var line = d3.svg.line()
			.x(function(d){return d.x;})
			.y(function(d){return height - d.y;})
			.interpolate("linear");

	function genTestData(lStep,rStep){
		dataset = [];
		data0 = [];
		data1 = [];
		data2 = [];
		data3 = [];
		data4 = [];
		for(i=lStep;i<rStep;i+=1){
			var term = new Object();
			term.state = 1;
			term.x = i;
			term.y = Math.abs(Math.sin(i*3.14/40)*50);
			data0.push(term);
		}
		for(i=lStep;i<rStep;i+=1){
			var term = new Object();
			term.state = 1;
			term.x = i;
			term.y = Math.sin(i*3.14/70)*20+30;
			data1.push(term);
		}
		for(i=lStep;i<rStep;i+=1){
			var term = new Object();
			term.state = 1;
			term.x = i;
			term.y = 50;
			data2.push(term);
		}
		for(i=lStep;i<rStep;i+=1){
			var term = new Object();
			if(i<20){
				term.state = 1;
				term.x = i;
				term.y = -1.5*i +50; 
			}
			else{
				term.state = 0;
				term.x = i;
				term.y = 0;
			}
			data3.push(term);
		}
		for(i=lStep;i<rStep;i+=1){
			var term = new Object();
			if(i<20){
				term.state = 2;
				term.x = i;
				term.y = i;
			}
			else{
				term.state = 1;
				term.x = i;
				term.y = i/10+18;
			}
			data4.push(term);
		}

		dataset = {'b':data1,'a':data0,'c':data2,'d':data3,'e':data4};
		// dataset[0] = data0;
		// dataset[1] = data1;
		// dataset[2] = data2;
		return dataset;
	}

	function genPathFromOffset(offset, stepAmount, dataset){
		path = [];
		var flag;
		var i,j;

		for(i=0; i<pathOrder.length; i++){
			flag = 0;
			name = pathOrder[i];
			twoPath = [[],[]];
			for(j=0; j<stepAmount; j++){
				if(dataset[name][j].state == 1){
					if(flag == 0){
						var term = new Object();

						flag = 1;
						term.x = j*step;
						term.y = offset[j]+dataset[name][j].y;
						twoPath[0].push(term);
					}
					var term = new Object();
					term.x = j*step;
					term.y = offset[j];
					twoPath[0].push(term);
				}
				else if(dataset[name][j].state == 2){
					var term = new Object();
					term.x = j*step;
					term.y = offset[j];
					twoPath[1].push(term);
				}
			}
			for(j=stepAmount-1; j>=0; j--){
				if(dataset[name][j].state == 1){
					var term = new Object();
					term.x = j*step;
					term.y = offset[j]+dataset[name][j].y;
					twoPath[0].push(term);
					offset[j] = offset[j] + dataset[name][j].y+intervel;
				}
				else if(dataset[name][j].state == 2){
					var term = new Object();
					term.x = j*step;
					term.y = offset[j]+dataset[name][j].y;
					twoPath[1].push(term);
					offset[j] = offset[j] + dataset[name][j].y+intervel;
				}
			}

			var term = new Object();
			term.x = 0;
			term.y = offset[0]+dataset[name][0].y;
			twoPath[1].push(term);

			path[i] = twoPath;
		}

		return path;
	}

	function genStreamData(dataset, name, stepAmount, flag, base){
		var offset = [];
		var ceiling;
		var path = [];
		var i,j;

		for(j=0; j<stepAmount; j++){
			ceiling = 0;
			i = 0;
			while(pathOrder[i] != name){
				ceiling += dataset[pathOrder[i]][j].y + intervel;
				i++;
			}
			if(flag == 0){
				ceiling += dataset[pathOrder[i]][j].y/2;
			}
			else{
				if(pathOrder.indexOf(name)<(pathOrder.length-1)/2){
					ceiling += dataset[pathOrder[i]][j].y;
				}
			}
			offset[j] = base - ceiling;
		}
		path = genPathFromOffset(offset, stepAmount, dataset);
		
		return path;
	}

	// function genNewData(dataset, name, stepAmount, base){
	// 	var offset = [];

	// 	for(j=0; j<stepAmount; j++){
	// 		ceiling = 0;
	// 		i = 0;
	// 		while(pathOrder[i] != name){
	// 			ceiling += dataset[pathOrder[i]][j].y + intervel;
	// 			i++;
	// 		}
	// 		if(pathOrder.indexOf(name)<(pathOrder.length-1)/2){
	// 			ceiling += dataset[pathOrder[i]][j].y;
	// 		}
	// 		//ceiling += dataset[pathOrder[i]][j].y/2;
	// 		offset[j] = base - ceiling;
	// 	}

	// 	path = genPathFromOffset(offset, stepAmount, dataset);
	// 	return path;
	// }

	function mouseleave(){
		var newPath = [];

		for(i=0; i<3; i++){
			newPath[i] = genStreamData(dataset_whole[i], pathOrder[Math.floor((pathOrder.length)/2)], step_amount[i], 0, basic_base);
		}

		d3.selectAll(".layer")
			.data(newPath)
			.selectAll("g")
			.data(function(d) { return d; })
			.style({"stroke":"none"})
			.selectAll("path")
			.data(function(d) { return d; })
			.transition()
			.duration(1000)
			.attr("d",function(d){
				return line(d);
			});

		d3.selectAll(".one_bar")
			.style({
				"border":function(d,i){
					if(recentTopic[i] == name){
						return "none";
					}
				},
				"width":function(d,i){
					return barWidth+"px";
				},
				"height":function(d,i){
					var h = totalHeight*recentHot[i]/d3.sum(recentHot);
					return h+"px";
				},
		});
	}

	function mouseenter(name){
		var newPath = [];
		var baseUp,baseDown,base;
		var selected;
		var i = 0;

		baseDown = 0;
		baseUp = 0;
		while(pathOrder[i] != name){
			baseDown += dataset_whole[0][pathOrder[i]][0].y + intervel;
			i++;
		}
		if(pathOrder.indexOf(name)<(pathOrder.length-1)/2){
			baseDown += dataset_whole[0][pathOrder[i]][0].y;
			i++;
		}
		while(i < pathOrder.length){
			baseUp += dataset_whole[0][pathOrder[i]][0].y + intervel;
			i++;
		}

		base = (height+baseDown-baseUp)/2;

		for(i=0; i<3; i++){
			newPath[i] = genStreamData(dataset_whole[i], name, step_amount[i], 1, base);
		}

		d3.selectAll(".layer")
			.data(newPath)
			.selectAll("g")
			.data(function(d) { return d; })
			.style({'stroke':function(d,i){
				if(pathOrder[i] == name){
					return 'red';
				}
			}})
			.selectAll("path")
			.data(function(d) { return d; })
			.transition()
			.duration(1000)
			.attr("d",function(d){
				return line(d);
			});

		d3.selectAll(".one_bar")
			.style({
				"border":function(d,i){
					if(recentTopic[i] == name){
						return "2px solid #f00";
					}
				},
				"width":function(d,i){
					if(recentTopic[i] == name){
						return (barWidth-4)+"px";
					}
					else{
						return barWidth;	
					}
				},
				"height":function(d,i){
					var h = totalHeight*recentHot[i]/d3.sum(recentHot);
					if(recentTopic[i] == name){
						return (h-4)+"px";
					}
					else{
						return h;
					}
				},
				"z-index":20
		});
	}

	function drawWindow(dataset,left,right,stepAmount){
		var baseDown,baseUp;
		var name = pathOrder[Math.floor((pathOrder.length)/2)];
		var i;

		baseDown = 0;
		baseUp = 0;
		i = 0;
		while(pathOrder[i] != name){
			baseDown += dataset_whole[0][pathOrder[i]][0].y + intervel;
			i++;
		}
		baseDown += dataset_whole[0][pathOrder[i]][0].y/2;
		baseUp += dataset_whole[0][pathOrder[i]][0].y/2;
		i++;
		while(i < pathOrder.length){
			baseUp += dataset_whole[0][pathOrder[i]][0].y + intervel;
			i++;
		}

		basic_base = (height+baseDown-baseUp)/2;
		
		pathData = genStreamData(dataset, name, stepAmount, 0, basic_base);

		svg.append("g")
			.attr("class","layer")
			.selectAll("g")
			.data(pathData)
			.enter()
			.append("g")
			.style({'fill':function(d,i){return colorTable[colorsInOrder[i]%colorNum]},
					})
			.on("mouseenter",function(d,i){
				mouseenter(pathOrder[i]);
			})
			.on("mouseleave",function(d,i){
				//sleep(50);
				mouseleave()
			})
			.selectAll("path")
			.data(function(d){return d;})
			.enter()
			.append("path")
			.attr("d",function(d){
				return line(d);
			})
			.attr("transform", "translate("+left+",0)")
			.style({'fill-opacity':function(d,i){
				if(i==1){
					return 0;
				}},
				'stroke':function(d,i){
				if(i==1){
					return 'none';
				}},
				'stroke-width':function(d,i){
				if(i==0){
					return 2;
				}},
			});
	}

	function timeTostr(time){
		var hour,min;
		if(time == -1){
			return "";
		}
		if((time/60)<10){
			hour = "0"+(Math.floor(time/60)).toString();
		}
		else{
			hour = (Math.floor(time/60)).toString();
		}
		if((time%60)<10){
			min = "0"+(Math.floor(time%60)).toString();
		}
		else{
			min = (Math.floor(time%60)).toString();
		}

		return hour+":"+min;
	}

	function sleep(d){
		for(var t = Date.now();Date.now() - t <= d;);
	}

	function drawAxis(){
		var xScale = [];
		var xAxis = [];
		var left = [];
		var padding = 7;
		var virtualData = [1,2,3];
		var i;

		calTime();

		for(i = 0; i < 3; i++){
			xScale[i] = d3.scale.linear().domain([0,right_pos[i]-left_pos[i]]).range([0,right_pos[i]-left_pos[i]-padding]);
			left[i] = left_pos[i]+1;
		}

		for(i=0; i<3; i++){
			xAxis = d3.svg.axis()
				.scale(xScale[i])
				.orient("bottom")
				.ticks(0);

			svg.append("g")
				.attr("class","axis")
				.attr("id","axis_"+i)
				.attr("transform", "translate("+left[i]+","+height+")")
				.call(xAxis)
		}

		left[0] = left_pos[0]+1;
		left[1] = right_pos[0]-padding/2;
		left[2] = right_pos[1]-padding/2;
		left[3] = right_pos[2]-padding/2;

		svg.append("g")
			.attr("class","axis")
			.attr("id","axis_text")
			.attr("transform", "translate(0,"+height+")");

		var g_text = document.getElementById("axis_text");
		
		for(i=0; i<4; i++){
			d3.select(g_text)
				.selectAll("text")
				.data(left)
				.enter()
				.append("text")
				.text(function(d,i){
					return timeTostr(time_minute[i]);
				})
				.attr("x",function(d){return d})
				.attr("y",16)
				.style({"text-anchor": "middle"});
		}



		svg.append("g")
			.attr("id","day-line")
			.attr("transform","translate("+0+","+(height)+")")
			.selectAll("path")
			.data([[left_pos[0],posTwoDaysBetween],[posTwoDaysBetween,right_pos[2]-padding+2]])
			.enter()
			.append("path")
			.attr("d",function(d){
				return d3.svg.line()
							.x(function(d){return d})
							.y(function(d){return 0})
							.interpolate("linear")(d);
			})
			.style({
				"stroke":function(d,i){
					if(i==0){
						return "orange";
					}
					else{
						return "blue";
					}
				},
				"stroke-width":"2px"
			});
	}


	function mouseMove(e){
		var div = document.getElementById("WhiteLine");
		var x = e.clientX;
		var time;

		d3.select('#WhiteLine')
			.style({'left':''+(parseInt(x)+5)+'px'});

		time = timeTostr(calTimeByPos(parseInt(x)+5));

		d3.select('#guide-line')
			.select('text')
			.attr("x",parseInt(x)+5)
			.text(time);

	}

	function calTimeByPos(pos){
		var i;
		var time;
		var c_section,n_section;
		var left = [];
		var right = [];
		for(i=0; i<3; i++){
			left[i] = left_pos[i]+7;
			right[i] = right_pos[i]+2;
		}
		n_section = -1;
		for(i=0; i<3; i++){
			if(left[i]+1<=pos && right[i]>=pos){
				n_section = i;
			}
			if(left[i]<=posTwoDaysBetween && right[i]>=posTwoDaysBetween){
				c_section = i;
			}
		}
		if(n_section == -1){
			return -1;
		}
		if(n_section<c_section || n_section>c_section){
			time = time_minute[n_section] - time_density[n_section]*Math.floor((pos-left[n_section])/step);
			//time = Math.floor(time_minute[n_section]+(time_minute[n_section+1]-time_minute[n_section])*(pos-left[n_section])/(right[n_section]-left[n_section]));
		}
		else if(n_section==c_section){
			if(pos <= posTwoDaysBetween+2*step){
				time = time_minute[n_section] - time_density[n_section]*Math.floor((pos-left[n_section])/step);
				//time = Math.floor(time_minute[n_section]+(0-time_minute[n_section])*(pos-left[n_section])/(posTwoDaysBetween-left[n_section]));
			}
			else{
				time = 24*60 - time_density[n_section]*Math.floor((pos-posTwoDaysBetween)/step);
				//time = Math.floor(24*60+(time_minute[n_section+1]-24*60)*(pos-posTwoDaysBetween)/(right[n_section+1]-posTwoDaysBetween));
			}
		}
		return time;
	}

	function drawLine(){
		var pos = 200;
		var time;
		var guideline = d3.select('#svg-use')
			.append("g");

		guideline.append("div")
			.attr('id','WhiteLine')
			.style({'background-color':'White',
					'height':'340px',
					'top':marginTop+'px',
					'left':pos+'px',
					'width':'1px',
					'position':'absolute'
				});

		time = timeTostr(calTimeByPos(pos));
		svg.append("g")
			.attr("class","axis")
			.attr("id","guide-line")
			.attr("transform","translate(0,320)")
			.append("text")
			.attr("x",pos)
			.attr("y",-2)
			.style({"text-anchor":"middle"})
			.text(time);

	}

	function flocculate(_this){
	  	_this.selectAll().flocculate();
	  	_this.strata.update(_this);
	}

	function createToken(_this, i, data){
        var token = {
          	category:0,
          	fillStyle:colorTable[recnetColorsInOrder[i]],
          	size:data,
          	callback:{
          	}
        }
        _this.addToken(token);
    }

    function updateTopicBar(){
        var topic_bar = d3.select('#topic_bar');
        var dataset = [];
        var total_height = 0;

        for(i=0; i<recentTopic.length; i++){
          	var term = new Object();
          	term.height = recentHot[i];
          	term.color = recnetColorsInOrder[i];
          	term.bottom = total_height;
          	dataset.push(term);
          	total_height += recentHot[i];
        }

        topic_bar.selectAll("div")
          	.data(dataset)
          	.style({
            	'height':function(d){ return d.height*totalHeight/total_height+'px'; },
            	'bottom':function(d){ return d.bottom*totalHeight/total_height+'px'; },
            	'background-color':function(d){ return colorTable[d.color]; }
          	});
    }

	function initBar(){
		var bar_height_now;
		var max_hot;

		marginTop = $("#svg-use").offset().top
		maxData = recentTopic.length * 14;
		bar_height_now = Math.floor(second/5)*recentTopic.length;
	  	totalHeight = bar_height_now*barHeight/maxData;

	  	max_hot = d3.max(recentHot);

	  	sceneSettings = {
	  	x:0,
	  	y:0,
	  	width:barWidth,
	  	height:barHeight,
	  	spacer:0,
	  	data:{
	        model:[{label:"total"}],
	        strata:[[{initValue:bar_height_now,label:"Strata"}]],
	        stream:{provider:'token',refresh:1000/6}
	  	},
	  	sedimentation:{
	    	token:{
	      		size:{minimum:2}
	    	},
	    	suspension:{
	      		decay:{power:1},
	    	},
	    	aggregation:{
	      		height:barHeight,
	      		maxData:maxData,
	    	}
	  	}};

		barChart = $("#barChart").vs(sceneSettings).data('visualSedimentation');

		for(i=0; i<recentTopic.length; i++){
	  		createToken(barChart,i,recentHot[i]*10/max_hot);
		}

		d3.select("#barChart")
		  	.select("div")
		  	.style({'position':'absolute','top':marginTop});


		d3.select('#svg-use')
		  	.append("div")
		  	.style({
		    	'width':barWidth+'px',
			    'height':barHeight+'px',
			    'position':'absolute',
		    	'top':marginTop+'px'
		  	})
		  	.append("div")
		  	.attr("id","topic_bar")
		  	.style({
		    	'width':'100%',
		    	'height':'100%',
		    	'position':'relative',
			})
		  	.selectAll("div")
		  	.data(recentHot)
		  	.enter()
		  	.append("div")
		  	.attr("class","one_bar")
		  	.style({
		    	'width':barWidth+"px",
		    	'height':'0px',
		    	'position':'absolute',
		    	'bottom':'0px',
		    	'background-color':'#999999',
		    	'z-index':20
		  	})
		  	.on("mouseenter",function(d,i){
		  		mouseenter(recentTopic[i]);
		  	})
		  	.on("mouseleave",function(d,i){
		  		mouseleave();
		  	});

		updateTopicBar();

		svg.append("g")
			.attr("id","second-clock")
			.attr("transform", "translate(0,"+height+")")
			.append("text")
			.text(second+"s")
			.attr('x',barWidth/2)
			.attr('y',16)
			.style({"text-anchor":"middle"});
	}

	function calTime(){
		var time = recentTime;
		var i;
		var left = [];
		var right = [];
		for(i=0; i<3; i++){
			left[i] = left_pos[i]+1;
			right[i] = right_pos[i];
		}

		for(i=0; i<3; i++){
			time_minute[i] = time;
			if(time < time_density[i]*Math.floor((right[i]-left[i])/step)){
				posTwoDaysBetween = left[i] + (time/time_density[i])*step;
				time = time - time_density[i]*Math.floor((right[i]-left[i])/step) + 24*60;
			}
			else{
				time = time - time_density[i]*Math.floor((right[i]-left[i])/step);
			}
		}

		time_minute[i] = time;
	}

	function update(){
		var max_hot = d3.max(recentHot);

        if((second % 5) == 0) {
          	totalHeight += recentTopic.length*barHeight/maxData;
          	flocculate(barChart);
          	updateTopicBar();
          	for(i=0; i<recentTopic.length; i++){
           	 	createToken(barChart,i,recentHot[i]*10/max_hot);
          	}
        }
        second++;

        d3.select("#second-clock")
        	.select("text")
        	.text(second+"s");
    }

	function ready(){

		var i;

		for(i=0; i<3; i++){
			step_amount[i] = Math.floor((right_pos[i] - left_pos[i])/step)
		}

		dataset_whole[0] = genTestData(0,step_amount[0]+1);
		dataset_whole[1] = genTestData(step_amount[0],step_amount[0]+step_amount[1]+1);
		dataset_whole[2] = genTestData(step_amount[0]+step_amount[1],step_amount[0]+step_amount[1]+step_amount[2]+1);

		svg = d3.select("#svg-use")
			.on("mousemove",function(){mouseMove(event);})
			.append("svg")
			.attr("id","svg")
			.attr("width",width)
			.attr("height",height+marginBottom);

		initBar();

		for(i=0; i<3; i++){
			drawWindow(dataset_whole[i],left_pos[i],right_pos[i],step_amount[i]);
		}

		drawAxis();
		drawLine();

		setInterval(update, 1000);
	}
	</script>
	<style type="text/css">
	</style>
</head>
<body onload="ready()">
	<h2	align="center">微博排行榜可视化</h2>
	<div id="barChart"></div>
	<div id = "svg-use"></div>
</body>
</html>